#include <Arduino.h>
#include <SPI.h>
// 
// #define ADC_DUAL_ADCS


const int emit_chirp_pin = 17; // 13
const int itsy_has_spi_data = 18;// 5

const int spi_ss = 16; // 7



// extern void dumpDMA_structures(DMABaseClass *dmabc);

// // Going to try two buffers here  using 2 dmaSettings and a DMAChannel
const uint32_t buffer_size = 1000;


#define UART_BUF_SIZE buffer_size * 2
volatile uint16_t uart_send_buffer[UART_BUF_SIZE];

void GetData(bool);

#define SPI_RX_BUF_SIZE buffer_size*2*2
byte spi_rx_buf[SPI_RX_BUF_SIZE];
SPISettings itsy_spi_settings(60000000,LSBFIRST,SPI_MODE0);


enum LISTENER_SERIAL_CMD
{
  NONE = 0,
  START_LISTEN = 1,
  STOP_LISTEN = 2,
  ACK_REQ = 3,
  ACK = 4,
  ERROR = 100
};

void setup()
{
  // Serial.println("Starting");
  delay(500);
  pinMode(LED_BUILTIN, OUTPUT);

  pinMode(emit_chirp_pin,OUTPUT);
  pinMode(itsy_has_spi_data,INPUT_PULLDOWN);
  
  pinMode(spi_ss,OUTPUT);
  digitalWrite(spi_ss,HIGH);
  SPI.begin();

  digitalWriteFast(LED_BUILTIN, LOW);
}

volatile bool sendData = false;
unsigned long sendStartTime = 0;
uint16_t times_to_send = 0;
volatile uint16_t times_sent = 0;

volatile bool new_spi_data = false;

void loop()
{

  // Maybe only when both have triggered?
  // if (abdma1.interrupted() && abdma2.interrupted())
  // {
  //   GetData(sendData);
  // }


  if (Serial.available())
  {
    LISTENER_SERIAL_CMD cmd = (LISTENER_SERIAL_CMD)Serial.read();

    switch (cmd)
    {
    case LISTENER_SERIAL_CMD::ACK:
    {
    }
    break;
    case LISTENER_SERIAL_CMD::ACK_REQ:
    {
      Serial.flush();
      Serial.write(LISTENER_SERIAL_CMD::ACK);
      Serial.send_now();
      Serial.flush();
      sendData = false;
      digitalWriteFast(emit_chirp_pin,LOW);
      digitalWriteFast(LED_BUILTIN, LOW);
      Serial.flush();
    }
    break;
    case LISTENER_SERIAL_CMD::START_LISTEN:
    {
      sendData = true;
      digitalWriteFast(LED_BUILTIN, HIGH);
      digitalWriteFast(emit_chirp_pin,HIGH);

      


      // Serial.flush();
      sendStartTime = millis();
    }
    break;
    case LISTENER_SERIAL_CMD::STOP_LISTEN:
    {
      sendData = false;
      digitalWriteFast(LED_BUILTIN, LOW);
      digitalWriteFast(emit_chirp_pin,LOW);
      Serial.flush();
    }
    break;
    case LISTENER_SERIAL_CMD::ERROR:
    {
    }
    break;
    default:
      break;
    }


  }

  if(digitalReadFast(itsy_has_spi_data) == HIGH){
    SPI.beginTransaction(itsy_spi_settings);
    digitalWriteFast(spi_ss, LOW);
    delayMicroseconds(50);
    SPI.transfer(&spi_rx_buf,SPI_RX_BUF_SIZE);

    digitalWriteFast(spi_ss,HIGH);
    SPI.endTransaction();
    new_spi_data = true;
  }

  if (sendData){

    if ( new_spi_data){
      
      for (size_t i =0; i < SPI_RX_BUF_SIZE; i+=2){
        Serial.write(spi_rx_buf[i]);
        Serial.write(spi_rx_buf[i+1]);
        if (i % 64 == 0){
          Serial.send_now();
          Serial.flush();
        }
      }
      Serial.send_now();
      Serial.flush();
      new_spi_data = false;
    }
  }
}

// void GetData(bool send)
// {
//   volatile uint16_t *adc0_pbuffer = abdma1.bufferLastISRFilled();
//   volatile uint16_t *adc0_end_pbuffer = abdma1.bufferCountLastISRFilled() + adc0_pbuffer;

//   volatile uint16_t *adc1_pbuffer = abdma2.bufferLastISRFilled();
//   volatile uint16_t *adc1_end_pbuffer = abdma2.bufferCountLastISRFilled() + adc1_pbuffer;

//   if ((uint32_t)adc0_pbuffer >= 0x20200000u)
//     arm_dcache_delete((void *)adc0_pbuffer, sizeof(dma_adc_buff1));
//   if ((uint32_t)adc1_pbuffer >= 0x20200000u)
//     arm_dcache_delete((void *)adc1_pbuffer, sizeof(dma_adc_buff1));

//   size_t index = 0;

//   while (adc0_pbuffer < adc0_end_pbuffer)
//   {
//     uart_send_buffer[index] = *adc0_pbuffer;
//     adc0_pbuffer++;
//     index += 2;
//   }
//   // uart_send_buffer[2] = index;

//   // index = UART_BUF_SIZE/2;
//   // uart_send_buffer[index] = ('R'<<8)
//   index = 1;
//   while (adc1_pbuffer < adc1_end_pbuffer)
//   {
//     uart_send_buffer[index] = *adc1_pbuffer;
//     adc1_pbuffer++;
//     index += 2;
//   }

//   index = UART_BUF_SIZE;

//   // Serial.println(abdma1.interruptDeltaTime());

//   abdma1.clearInterrupt();
//   abdma2.clearInterrupt();

//   // send data
//   if (!send)
//   {
//     // clear flags
//     Serial.flush();
//     return;
//   }

//   for (size_t i = 0; i < index; i++)
//   {
//     Serial.write(uart_send_buffer[i] & 0xff);
//     Serial.write(uart_send_buffer[i] >> 8 & 0xff);
//     if (i % 64 == 0)
//     {
//       Serial.send_now();
//       Serial.flush();
//     }
//   }
//   Serial.send_now();
//   Serial.flush();
// }
