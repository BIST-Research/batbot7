/*
 * Author: Ben Westcott
 * Date created: 1/18/24
 */
#include <serial_handler.hpp>

#include <ml_clocks.h>
#include <ml_dac_common.h>
#include <ml_dac0.h>
#include <ml_dmac.h>
#include <ml_port.h>
#include <ml_tcc_common.h>
#include <ml_tcc2.h>
#include <ml_eic.h>

// 2**15
#define EMIT_BUF_LEN 32768

#define DEFAULT_EMIT_LEN 3000
#define DEFAULT_RECV_CHNKS 12

// channel used for dmac and evsys
#define EMIT_CHANNEL 0x02

// triggers emission
#define EMIT_SOFT_TRIGGER() (EVSYS->SWEVT.bit.CHANNEL2 = 0x01)

// holds waveform to emit (dma steps through this buffer)
uint16_t emit_buffer[EMIT_BUF_LEN];
// holds waveform as it comes in from the host.
// Is copied to emit buffer when the entire waveform has been sent
uint16_t cpy_buffer[EMIT_BUF_LEN];
uint8_t *cpy_ptr;

uint16_t emit_len;
uint16_t upd_emit_len;

// number of chunks expected to recv entire waveform
uint16_t n_recv_chunks;
uint16_t n_chunks_cnt;

// are we recving new data?
_Bool recv;
// are we emitting?
_Bool chirping;

static DmacDescriptor base_descriptor[3] __attribute__((aligned(16)));
static volatile DmacDescriptor wb_descriptor[3] __attribute__((aligned(16)));

// D4 --> PA14
const ml_pin_settings dac_timer_pin = {PORT_GRP_A, 14, PF_F, PP_EVEN, OUTPUT_PULL_DOWN, DRIVE_ON};
// D10 --> PA20
const ml_pin_settings amp_pin = {PORT_GRP_A, 20, PF_A, PP_EVEN, OUTPUT_PULL_DOWN, DRIVE_ON};
// A0 --> PA02
const ml_pin_settings dac_pin = {PORT_GRP_A, 2, PF_B, PP_EVEN, ANALOG, DRIVE_ON};

const ml_pin_settings emit_trigger_pin = {PORT_GRP_A, 16, PF_A, PP_EVEN, INPUT_PULL_DOWN, DRIVE_OFF}; 

#define AMP_DISABLE() (logical_set(&amp_pin))
#define AMP_ENABLE() (logical_unset(&amp_pin))

const uint32_t emit_dmac_channel_settings =
(
  // single burst per transfer
  DMAC_CHCTRLA_BURSTLEN_SINGLE |
  // dma acts a transfer per tigger source (dma request)
  DMAC_CHCTRLA_TRIGACT_BURST |
  // set dma requests to be generated by the dac timer
  DMAC_CHCTRLA_TRIGSRC(TCC2_DMAC_ID_OVF)
);

const uint16_t emit_dmac_descriptor_settings = 
(
  // dmac suspends and interrupts on completion
  DMAC_BTCTRL_BLOCKACT_BOTH |
  // transmit half words (uint16_t)
  DMAC_BTCTRL_BEATSIZE_HWORD |
  // events trigger per block operation
  DMAC_BTCTRL_EVOSEL_BLOCK |
  // increment source pointer
  DMAC_BTCTRL_SRCINC |
  DMAC_BTCTRL_VALID
);

void _set_emit_dmac_descriptor(uint32_t btcnt)
{
    DMAC_descriptor_init
    (
        emit_dmac_descriptor_settings,
        btcnt,
        (uint32_t)emit_buffer + (btcnt * sizeof(uint16_t)),
        (uint32_t)&DAC->DATA[0].reg,
        (uint32_t)&base_descriptor[EMIT_CHANNEL],
        &base_descriptor[EMIT_CHANNEL]
    );
}

void _emit_dmac_init(void)
{
    DMAC_init(base_descriptor, wb_descriptor);

    DMAC_channel_init
    (
        (ml_dmac_chnum_t)EMIT_CHANNEL,
        emit_dmac_channel_settings,
        (ml_dmac_chprilvl_t)DMAC_CHPRILVL_PRILVL_LVL0
    );

    EVSYS->USER[EVSYS_ID_USER_DMAC_CH_2].bit.CHANNEL = EMIT_CHANNEL + 0x01;
    EVSYS->Channel[EMIT_CHANNEL].CHANNEL.reg = 
    (
        // event triggers on rising edge of event generator
        EVSYS_CHANNEL_EDGSEL_RISING_EDGE |
        // evsys synchronizes generator and user(s) on event trigger
        EVSYS_CHANNEL_PATH_RESYNCHRONIZED |
        // set event generator (0x00 = none, i.e., triggered from SWEVT)
        EVSYS_CHANNEL_EVGEN(0x00)
    );

    // dma channel as a user responds to event by resuming operation
    DMAC->Channel[EMIT_CHANNEL].CHEVCTRL.bit.EVACT = DMAC_CHEVCTRL_EVACT_RESUME_Val;
    // obv enable event input
    DMAC->Channel[EMIT_CHANNEL].CHEVCTRL.bit.EVIE = 0x01;

    // construct dma descriptor and cpyto base descriptor
    _set_emit_dmac_descriptor(DEFAULT_EMIT_LEN);

    // cpu interrupt triggers on transfer complete
    DMAC_channel_intenset((ml_dmac_chnum_t)EMIT_CHANNEL, DMAC_2_IRQn, DMAC_CHINTENSET_TCMPL, 1);

    ML_DMAC_ENABLE();
    ML_DMAC_CHANNEL_ENABLE(EMIT_CHANNEL);
    // start w/ channel suspended
    DMAC_suspend_channel(EMIT_CHANNEL);
}

void emit_setup(void)
{
    DOTSTAR_SET_ORANGE();

    DAC_init();
    DAC0_init();
    peripheral_port_init(&dac_pin);
    DAC0_enable();
    DAC_enable();

    // For timing dma to send a sample at 1 MSPS
    TCC2_init();
    peripheral_port_init(&dac_timer_pin);
    TCC_enable(TCC2);

    OSCULP32K_init();
    eic_init();
    hardware_int_init();
    peripheral_port_init(&emit_trigger_pin);
    eic_enable();


    _emit_dmac_init();

    //memset((void *)cpy_buffer, 0, sizeof(cpy_buffer));
    //memset((void *)emit_buffer, 0, sizeof(emit_buffer));

    emit_len = upd_emit_len = DEFAULT_EMIT_LEN;
    n_recv_chunks = DEFAULT_RECV_CHNKS;
    n_chunks_cnt = 0;
    cpy_ptr = (uint8_t *)cpy_buffer;

    recv = false;
    chirping = false;
}

uint16_t e_ser_ret_val = 0;

uint16_t emit_loop
(
    uint8_t rx_buffer[SER_BUF_LEN], 
    // type of frame that serial recvd
    uint8_t rx_frame_type,
    uint8_t tx_buffer[SER_BUF_LEN]
)
{
    if(recv)
    {
        //DOTSTAR_SET_RED();
        if (rx_frame_type == RX_DATA_FRAME)
        {
            // copy recvd chunk to copy buffer, and increment cpy ptr by chunk size
            memcpy((void *)cpy_ptr, (const void *)rx_buffer, SER_BUF_LEN);
            cpy_ptr += SER_BUF_LEN;
            n_chunks_cnt++;
        }

        if(rx_frame_type == RX_ERR)
        {
            DOTSTAR_SET_RED();
        }

        if(n_chunks_cnt == n_recv_chunks && !chirping)
        {
            // Clear eic interrupt so emission doesnt occur while copying to emit buffer
            EIC->INTENCLR.reg |= (1 << EIC_INTENCLR_EXTINT(0));

            memcpy((void *)emit_buffer, (const void *)cpy_buffer, sizeof(uint16_t) * upd_emit_len);

            // Give dmac updated emission length
            _set_emit_dmac_descriptor(upd_emit_len);
            emit_len = upd_emit_len;

            n_chunks_cnt = 0;
            cpy_ptr = (uint8_t *)cpy_buffer;

            recv = false;
            
            // Set chirp interrupt after finished updating
            EIC->INTENSET.reg |= (1 << EIC_INTENSET_EXTINT(0));
            DOTSTAR_SET_BLUE();
        }
    }

    if(rx_frame_type == RX_MSG_FRAME && !recv)
    {
        _Bool buffer_update = (_Bool)rx_buffer[0];
        if(buffer_update)
        {
            // MSG buffer: | update? | new emission length | num chunks to expect |
            upd_emit_len = B_TO_H(rx_buffer[1], rx_buffer[2]);
            n_recv_chunks = B_TO_H(rx_buffer[3], rx_buffer[4]);
            recv = true;
        }
    }

    // tell serial handler that we want to continue reading
    return SER_RET_READ;
}

void DMAC_2_Handler(void)
{
    DMAC->Channel[2].CHINTFLAG.bit.TCMPL = 0x01;
    DOTSTAR_SET_ORANGE();
    chirping = false;
}

#if defined(BUILD_EMIT)
void EIC_0_Handler(void)
{
    // clr flags
    EIC->INTFLAG.reg = EIC_INTFLAG_MASK;

    //DOTSTAR_SET_ORANGE();

    if(!chirping)
    {
        EMIT_SOFT_TRIGGER();
        DOTSTAR_SET_GREEN();
        chirping = true;
    }
}
#endif
